# backend/app/services/alerta_service.py
# -*- coding: utf-8 -*-
"""
Exitus - AlertaService (M7.2) - VERSÃO PÓS-FIX MODEL
"""
from decimal import Decimal
from typing import Dict, List, Optional
from uuid import UUID
from sqlalchemy import and_
from app.database import db
from app.models.configuracao_alerta import ConfiguracaoAlerta
from app.models.ativo import Ativo

class AlertaService:
    @staticmethod
    def listar_alertas(usuario_id: UUID, ativo_id: Optional[UUID] = None, apenas_ativos: bool = True) -> List[Dict]:
        query = ConfiguracaoAlerta.query.filter(ConfiguracaoAlerta.usuario_id == usuario_id)

        if ativo_id:
            query = query.filter(ConfiguracaoAlerta.ativo_id == ativo_id)

        if apenas_ativos:
            # Agora podemos usar .ativo normalmente, pois o relacionamento mudou de nome
            query = query.filter(ConfiguracaoAlerta.ativo.is_(True))

        alertas = query.order_by(ConfiguracaoAlerta.timestamp_criacao.desc()).all()
        return [a.to_dict() for a in alertas]

    @staticmethod
    def verificar_alertas_usuario(usuario_id: UUID) -> List[Dict]:
        """
        Verifica todos os alertas ativos do usuário e retorna os disparados.
        """
        # Filtro ORM puro, assumindo que o Model foi corrigido (ativo_rel)
        # Se 'ativo' ainda for relacionamento, isso dará erro de Ambiguidade novamente.
        # Se isso acontecer, significa que o Model NÃO foi atualizado no container.
        
        # Tentativa Híbrida Segura: Tenta filtro direto, se der erro, captura
        try:
            alertas = ConfiguracaoAlerta.query.filter(
                and_(
                    ConfiguracaoAlerta.usuario_id == usuario_id,
                    ConfiguracaoAlerta.ativo.is_(True) 
                )
            ).all()
        except Exception:
            # Fallback se o model não foi atualizado: Filtra na memória
            # Isso é ineficiente mas funciona para destravar o erro
            todos = ConfiguracaoAlerta.query.filter_by(usuario_id=usuario_id).all()
            alertas = [a for a in todos if getattr(a, 'ativo', False) is True]

        disparados = []
        
        # Import local para evitar ciclo
        from app.services.portfolio_service import PortfolioService
        
        try:
            dash_data = None 
            
            for alerta in alertas:
                try:
                    trigger = False
                    valor_atual = Decimal('0')
                    mensagem = ""
                    
                    tipo = str(alerta.tipo_alerta.value) if hasattr(alerta.tipo_alerta, 'value') else str(alerta.tipo_alerta)
                    
                    # 1. Alertas de Preço
                    if tipo in ['QUEDA_PRECO', 'ALTA_PRECO'] and alerta.ativo_id:
                         # Tenta acessar relacionamento (ativo_rel ou ativo)
                         ativo_obj = getattr(alerta, 'ativo_rel', getattr(alerta, 'ativo', None))
                         
                         # Se ativo_obj for booleano (caso o rename tenha funcionado e o obj seja None), busca manual
                         if isinstance(ativo_obj, bool) or ativo_obj is None:
                             ativo_obj = Ativo.query.get(alerta.ativo_id)

                         if hasattr(ativo_obj, 'preco_atual') and ativo_obj.preco_atual:
                             valor_atual = ativo_obj.preco_atual
                             trigger = AlertaService.validar_condicao(alerta, valor_atual)
                             
                             if trigger:
                                direction = "subiu para" if tipo == 'ALTA_PRECO' else "caiu para"
                                mensagem = f"{ativo_obj.ticker} {direction} R$ {valor_atual}"

                    # 2. Alertas de Rentabilidade/Portfolio
                    elif tipo == 'META_RENTABILIDADE':
                        if not dash_data:
                            dash_data = PortfolioService.get_dashboard(usuario_id)
                        
                        target = float(alerta.condicao_valor)
                        if target < 1000: 
                            valor_atual = Decimal(str(dash_data.get('rentabilidade_percentual', 0)))
                            sufixo = "%"
                        else:
                            valor_atual = Decimal(str(dash_data.get('total_patrimonio', 0)))
                            sufixo = "R$"
                            
                        trigger = AlertaService.validar_condicao(alerta, valor_atual)
                        if trigger:
                            mensagem = f"Portfolio atingiu {valor_atual} {sufixo}"

                    if trigger:
                        alerta.timestamp_ultimo_acionamento = db.func.now()
                        disparados.append({
                            "alerta_id": str(alerta.id),
                            "titulo": alerta.nome,
                            "mensagem": mensagem,
                            "valor_disparo": float(valor_atual),
                            "data": "Agora"
                        })
                        
                except Exception as e:
                    print(f"Erro no alerta {alerta.id}: {e}")
                    continue

            db.session.commit()
            return disparados
            
        except Exception as e:
            db.session.rollback()
            raise e
            

    @staticmethod
    def validar_condicao(alerta, valor_atual: Decimal) -> bool:
        op = alerta.condicao_operador
        op_str = str(op.value) if hasattr(op, 'value') else str(op)
        threshold = alerta.condicao_valor
        try:
            val = float(valor_atual)
            th = float(threshold)
            if op_str in ['MAIOR', '>']: return val > th
            if op_str in ['MENOR', '<']: return val < th
            if op_str in ['IGUAL', '=']: return val == th
            if op_str == 'ENTRE':
                th2 = float(alerta.condicao_valor2) if alerta.condicao_valor2 else th
                return th <= val <= th2
            return False
        except:
            return False


    @staticmethod
    def _obter_valor_atual(alerta) -> Optional[Decimal]:
        # Se for alerta de preço, busca no ativo
        tipo = str(alerta.tipo_alerta.value) if hasattr(alerta.tipo_alerta, 'value') else str(alerta.tipo_alerta)
        
        if tipo in ['QUEDA_PRECO', 'ALTA_PRECO'] and alerta.ativo_id:
            # Aqui 'alerta.ativo' pode ser o relacionamento. Vamos tentar usar ativo_id + query direta para garantir
            ativo = Ativo.query.get(alerta.ativo_id)
            return ativo.preco_atual if ativo else None
        
        # Se for alerta de rentabilidade (Portfolio), mockamos por enquanto ou chamamos PortfolioService
        if tipo == 'META_RENTABILIDADE':
             # Import local para evitar ciclo
            from app.services.portfolio_service import PortfolioService
            dash = PortfolioService.get_dashboard(alerta.usuario_id)
            # Retorna rentabilidade %
            return Decimal(str(dash.get('rentabilidade_percentual', 0)))

        return Decimal('0')

    @staticmethod
    def verificar_alertas_usuario(usuario_id: UUID) -> List[Dict]:
        """
        Verifica todos os alertas ativos do usuário e retorna os disparados.
        Restaura a funcionalidade do motor de alertas.
        """
        # Usar SQL Textual para evitar o conflito do relacionamento 'ativo'
        alertas = ConfiguracaoAlerta.query.filter(
            and_(
                ConfiguracaoAlerta.usuario_id == usuario_id,
                text("ativo = true")
            )
        ).all()

        disparados = []
        
        # Import local para evitar ciclo
        from app.services.portfolio_service import PortfolioService
        try:
            # Pré-carregar dados do portfolio apenas se necessário
            dash_data = None 
            
            for alerta in alertas:
                try:
                    trigger = False
                    valor_atual = Decimal('0')
                    mensagem = ""
                    
                    tipo = str(alerta.tipo_alerta.value) if hasattr(alerta.tipo_alerta, 'value') else str(alerta.tipo_alerta)
                    
                    # --- Lógica de Verificação ---
                    
                    # 1. Alertas de Preço
                    if tipo in ['QUEDA_PRECO', 'ALTA_PRECO'] and alerta.ativo_id:
                         # Tenta pegar valor do objeto relacionamento ou busca direta
                         # Aqui 'alerta.ativo' é o OBJETO relacionamento (Ativo), não o boolean
                         ativo_obj = alerta.ativo 
                         if ativo_obj and ativo_obj.preco_atual:
                             valor_atual = ativo_obj.preco_atual
                             trigger = AlertaService.validar_condicao(alerta, valor_atual)
                             
                             if trigger:
                                direction = "subiu para" if tipo == 'ALTA_PRECO' else "caiu para"
                                mensagem = f"{ativo_obj.ticker} {direction} R$ {valor_atual}"

                    # 2. Alertas de Rentabilidade/Portfolio
                    elif tipo == 'META_RENTABILIDADE':
                        if not dash_data:
                            dash_data = PortfolioService.get_dashboard(usuario_id)
                        
                        # Decide se compara % ou R$
                        target = float(alerta.condicao_valor)
                        if target < 1000: # Assumindo %
                            valor_atual = Decimal(str(dash_data.get('rentabilidade_percentual', 0)))
                            sufixo = "%"
                        else:
                            valor_atual = Decimal(str(dash_data.get('total_patrimonio', 0)))
                            sufixo = "R$"
                            
                        trigger = AlertaService.validar_condicao(alerta, valor_atual)
                        if trigger:
                            mensagem = f"Portfolio atingiu {valor_atual} {sufixo}"

                    # --- Disparo ---
                    if trigger:
                        # Atualizar timestamp de último disparo
                        alerta.timestamp_ultimo_acionamento = db.func.now()
                        
                        disparados.append({
                            "alerta_id": str(alerta.id),
                            "titulo": alerta.nome,
                            "mensagem": mensagem,
                            "valor_disparo": float(valor_atual),
                            "data": "Agora"
                        })
                        
                except Exception as e:
                    print(f"Erro ao verificar alerta {alerta.id}: {e}")
                    continue

            db.session.commit()
            return disparados
            
        except Exception as e:
            db.session.rollback()
            raise e

